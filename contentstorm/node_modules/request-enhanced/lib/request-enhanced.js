// Generated by CoffeeScript 1.4.0
(function() {
  var Heap, defaults, fs, get, getFile, getHelper, getRequest, heap, mkdirs, popStuff, request, running, setDefaults,
    __slice = [].slice;

  request = require('request');

  fs = require('fs');

  Heap = require('heap');

  defaults = {
    maxAttempts: 10,
    priority: 0,
    timeout: 10000,
    retryDelay: 5000,
    defaultValue: '',
    pool: {
      maxSockets: Infinity
    },
    maxConcurrent: 100
  };

  setDefaults = function(newDefaults) {
    var d, _results;
    _results = [];
    for (d in newDefaults) {
      _results.push(defaults[d] = newDefaults[d]);
    }
    return _results;
  };

  get = function(options, regex, callback) {
    var defaultValue, processResults;
    defaultValue = typeof options === 'object' && (options.defaultValue != null) ? options.defaultValue : defaults.defaultValue;
    if (typeof options === 'string') {
      options = {
        url: options
      };
    }
    if (options.timeout == null) {
      options.timeout = defaults.timeout;
    }
    if (options.maxAttempts == null) {
      options.maxAttempts = defaults.maxAttempts;
    }
    if (options.pool == null) {
      options.pool = defaults.pool;
    }
    if (options.retryDelay == null) {
      options.retryDelay = defaults.retryDelay;
    }
    if (!callback && typeof regex === 'function') {
      callback = regex;
      regex = null;
    }
    return getHelper(options, processResults = function(err, result) {
      var fetched, i, index, inner, key, r, regexp, results, search, value, _i, _len, _ref, _ref1, _ref2;
      if (err != null) {
        return callback(err);
      }
      fetched = (result && typeof result !== "string" ? result.buffer.toString("utf8") : result || "");
      if (!(regex != null)) {
        return callback(null, fetched, null);
      }
      results = {};
      for (key in regex) {
        search = regex[key];
        regexp = search.regex;
        if (typeof regexp === 'string') {
          regexp = new RegExp(regexp, (search.multiple ? 'g' : '') + (!search.caseSensitive ? 'i' : '') + (search.multiline ? 'm' : ''));
        }
        result = fetched.match(regexp);
        if (!regexp.global) {
          if (!(search.results != null)) {
            if (result != null) {
              delete result.input;
            }
            results[key] = result || [];
          } else if (typeof search.results === 'number') {
            results[key] = (result != null) && result[search.results] ? result[search.results] : defaultValue;
          } else if (typeof search.results === 'object') {
            results[key] = {};
            _ref = search.results;
            for (value in _ref) {
              index = _ref[value];
              results[key][index] = (result != null) && result[value] ? result[value] : defaultValue;
            }
          } else {
            throw new Error('Unsupported results type. Results must be the integer index of the result or an object with keys being the indexes of the results.');
          }
        } else {
          regexp = new RegExp(regexp.source, (regexp.ignoreCase ? 'i' : '') + (regexp.multiline ? 'm' : ''));
          results[key] = [];
          _ref1 = result || [];
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            r = _ref1[i];
            inner = r.match(regexp);
            if (!(search.results != null)) {
              if (inner != null) {
                delete inner.input;
              }
              results[key][i] = inner || [];
            } else if (typeof search.results === 'number') {
              results[key][i] = (inner != null) && inner[search.results] ? inner[search.results] : defaultValue;
            } else if (typeof search.results === 'object') {
              results[key][i] = {};
              _ref2 = search.results;
              for (value in _ref2) {
                index = _ref2[value];
                results[key][i][index] = (inner != null) && inner[value] ? inner[value] : defaultValue;
              }
            } else {
              throw new Error('Unsupported results type. Results must be the integer index of the result or an object with keys being the indexes of the results.');
            }
          }
        }
      }
      return callback(null, fetched, results);
    });
  };

  getHelper = function(options, callback, attemptsLeft, lastError) {
    if (!(attemptsLeft != null)) {
      attemptsLeft = options.maxAttempts;
    }
    if (attemptsLeft <= 0) {
      return callback((lastError != null ? lastError : new Error('No attempts to fetch the URL were made')));
    }
    return request(options, function(error, response, body) {
      var e, _ref, _ref1, _ref2;
      if ((error && ((_ref = error.code) === 'ESOCKETTIMEDOUT' || _ref === 'ETIMEDOUT' || _ref === 'ECONNRESET' || _ref === 'ECONNREFUSED')) || (response && (500 <= (_ref1 = response.statusCode) && _ref1 < 600))) {
        e = error ? new Error("" + error.code + " error on " + options.url) : new Error("HTTP " + response.statusCode + " error fetching " + options.url);
        e.code = error ? error.code : response.statusCode;
        return setTimeout((function() {
          return getHelper(options, callback, --attemptsLeft, e);
        }), options.retryDelay);
      } else if (!error && (200 <= (_ref2 = response.statusCode) && _ref2 < 300)) {
        return callback(null, body);
      } else if (error) {
        e = new Error("Error fetching '" + options.url + "': " + error.message + " (" + error.code + ")");
        e.code = error.code;
        return callback(e);
      } else {
        e = new Error("HTTP " + response.statusCode + " error fetching " + options.url);
        e.code = response.statusCode;
        return callback(e);
      }
    });
  };

  getFile = function(options, filename, callback, attemptsLeft, lastError) {
    var path;
    if (typeof options === 'string') {
      options = {
        url: options
      };
    }
    if (options.timeout == null) {
      options.timeout = defaults.timeout;
    }
    if (options.maxAttempts == null) {
      options.maxAttempts = defaults.maxAttempts;
    }
    if (options.pool == null) {
      options.pool = defaults.pool;
    }
    if (options.retryDelay == null) {
      options.retryDelay = defaults.retryDelay;
    }
    if (!(attemptsLeft != null)) {
      attemptsLeft = options.maxAttempts;
    }
    if (attemptsLeft <= 0) {
      return callback(lastError);
    }
    path = filename.substr(0, filename.lastIndexOf('/'));
    return mkdirs(path, '0777', function(err) {
      var calledBack, req;
      if (err) {
        return callback(err);
      } else {
        req = request(options);
        req.pipe(fs.createWriteStream(filename));
        calledBack = false;
        req.on("end", function() {
          var e, _ref, _ref1;
          if (!calledBack) {
            calledBack = true;
            if ((200 <= (_ref = req.response.statusCode) && _ref < 300)) {
              return callback(null, filename);
            } else if ((500 <= (_ref1 = req.response.statusCode) && _ref1 < 600)) {
              e = new Error("HTTP " + req.response.statusCode + " error fetching file " + options.url);
              e.code = req.response.statusCode;
              return setTimeout((function() {
                return getFile(options, filename, callback, --attemptsLeft, e);
              }), options.retryDelay);
            } else {
              return callback(new Error("HTTP " + req.response.statusCode + " error fetching file " + options.url));
            }
          }
        });
        return req.on("error", function(error) {
          var e;
          if (!calledBack) {
            calledBack = true;
            e = new Error("" + error.code + " error fetching file " + options.url);
            e.code = error.code;
            return setTimeout((function() {
              return getFile(options, filename, callback, --attemptsLeft, e);
            }), options.retryDelay);
          }
        });
      }
    });
  };

  mkdirs = function(path, mode, callback) {
    var tryDirectory;
    tryDirectory = function(dir, cb) {
      return fs.stat(dir, function(err, stat) {
        if (err) {
          if (err.errno === 2 || err.errno === 32 || err.errno === 34) {
            if (dir.lastIndexOf("/") === dir.indexOf("/")) {
              return cb(new Error("Directory creation error: " + dir));
            } else {
              return tryDirectory(dir.substr(0, dir.lastIndexOf("/")), function(err) {
                if (err) {
                  return cb(err);
                } else {
                  return fs.mkdir(dir, mode, function(error) {
                    if (error && error.errno !== 17) {
                      return cb(new Error("Failed to create directory: " + dir));
                    } else {
                      return cb();
                    }
                  });
                }
              });
            }
          } else {
            return cb(err);
          }
        } else {
          if (stat.isDirectory()) {
            return cb();
          } else {
            return cb(new Error("File already exists: " + dir));
          }
        }
      });
    };
    path = (path.indexOf("\\") >= 0 ? path.replace("\\", "/") : path);
    if (path.substr(path.length - 1) === "/") {
      path = path.substr(0, path.length - 1);
    }
    return tryDirectory(path, callback);
  };

  running = 0;

  heap = new Heap(function(a, b) {
    return a.priority - b.priority;
  });

  popStuff = function() {
    return process.nextTick(function() {
      var next;
      if (!heap.size() || running >= defaults.maxConcurrent) {
        return;
      }
      running++;
      next = heap.pop();
      next["function"].apply(null, next["arguments"]);
      return popStuff();
    });
  };

  getRequest = function() {
    var a, args, callback, fetchback, filename, options, priority, regex, use, _i, _j, _len;
    options = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
    filename = regex = null;
    priority = defaults.priority;
    for (_j = 0, _len = args.length; _j < _len; _j++) {
      a = args[_j];
      switch (typeof a) {
        case 'string':
          filename = a;
          break;
        case 'object':
          regex = a;
          break;
        case 'number':
          priority = a;
      }
    }
    use = filename != null ? getFile : get;
    fetchback = function() {
      var results;
      results = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      running--;
      callback.apply(null, results);
      return popStuff();
    };
    heap.push({
      priority: priority,
      "arguments": [options, (filename != null ? filename : regex), fetchback],
      "function": use
    });
    return popStuff();
  };

  module.exports = {
    get: getRequest,
    setDefaults: setDefaults
  };

}).call(this);
